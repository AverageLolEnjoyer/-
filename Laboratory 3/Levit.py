import sys

def levit(graph, start):
    n = len(graph)
    INF = sys.maxsize  # Максимальное значение для представления бесконечности
    d = [INF] * n  # Инициализируем массив кратчайших расстояний бесконечностями
    d[start] = 0  # Расстояние от начальной вершины до неё самой равно 0

    q = []  # Очередь для обработки вершин
    q.append(start)
    in_queue = [False] * n  # Массив для отслеживания принадлежности вершины к очереди
    in_queue[start] = True

    while q:
        v = q.pop(0)  # Извлекаем вершину из очереди
        in_queue[v] = False
        for u in range(n):  # Проходим по всем вершинам
            if d[u] > d[v] + graph[v][u]:  # Если нашли короче путь до вершины u через v
                d[u] = d[v] + graph[v][u]  # Обновляем расстояние до вершины u
                if not in_queue[u]:  # Если вершина u не в очереди
                    if q and d[u] < d[q[0]]:  # Если новое расстояние до u меньше, чем до вершины в начале очереди
                        q.insert(0, u)  # Вставляем в начало очереди
                    else:
                        q.append(u)  # Добавляем в конец очереди
                    in_queue[u] = True
    return d


# Пример матрицы весов
graph_matrix = [
    [0, 2, 4, 0, 0, 0, 0],
    [0, 0, 0, 5, 12, 0, 0],
    [0, 0, 0, 0, 3, 7, 0],
    [0, 0, 0, 0, 4, 6, 0],
    [0, 0, 0, 0, 0, 11, 0],
    [0, 0, 0, 0, 0, 0, 2],
    [0, 0, 0, 0, 0, 0, 0]
]

start_node = 0

result = levit(graph_matrix, start_node)
print(result)